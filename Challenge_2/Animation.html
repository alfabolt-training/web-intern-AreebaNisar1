<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simple Morph + Particles Loader</title>
<style>
  
  html,body { height:100%; margin:0; display:flex; align-items:center; justify-content:center;
    background: linear-gradient(135deg,#10264d,#41246b); font-family:system-ui,Arial; }

  
  .wrap {
    width:120px; height:120px; position:relative;
    display:grid; place-items:center;
  }

  
  .shape {
    width:100px; height:100px;
    background: linear-gradient(135deg,#ff7eb3,#ff758c);

    animation:
      morph 4s linear infinite,
      hue 6s linear infinite;
   
    will-change: clip-path, transform, opacity, filter;
  }


  .particle {
    position:absolute;
    width:9px; height:9px;
    border-radius:50%;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.95), rgba(255,255,255,0.15) 60%);
    opacity:0;
    transform: translate(-50%,-50%) translate(0px,0px) scale(0.6);
    will-change: transform, opacity;
    pointer-events:none;
  }

  @keyframes morph {
    0% {
      clip-path: circle(50% at 50% 50%);
      transform: scale(1);
      opacity:1;
    }
    30% {
      clip-path: inset(0 round 12%); 
      transform: scale(1.06);
    }
    60% {
      clip-path: polygon(50% 0, 0 100%, 100% 100%); 
      transform: scale(0.95);
    }
    78% {
      opacity: 0; 
      transform: scale(1.25);
    }
    100% {
      clip-path: circle(50% at 50% 50%);
      opacity:1;
      transform: scale(1);
    }
  }

 
  @keyframes hue {
    from { filter: hue-rotate(0deg); }
    to   { filter: hue-rotate(360deg); }
  }

  
  @media (prefers-reduced-motion: reduce) {
    .shape { animation: none; filter: none; }
  }
</style>
</head>
<body>

  <div class="wrap" id="wrap">
    <div class="shape" id="shape" aria-hidden="true"></div>
  </div>

<script>

(function(){
  const wrap = document.getElementById('wrap');
  const shape = document.getElementById('shape');


  const prefersReduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  if (prefersReduce) return;

  const DURATION_MS = getAnimMs(shape, 'morph') || 4000; 
  const EXPLODE_AT = Math.round(DURATION_MS * 0.78);    
  const PARTICLE_COUNT = 14;
  const EXPLODE_TIME = 600;   
  const REASSEMBLE_DELAY = 900; 


  const particles = [];
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const p = document.createElement('div');
    p.className = 'particle';
   
    const hue = Math.round(320 + (i / PARTICLE_COUNT) * 120) % 360;
    p.style.background = `radial-gradient(circle at 30% 30%, hsl(${hue} 95% 85%), rgba(255,255,255,0.15) 60%)`;
    
    p.style.transition = `transform ${EXPLODE_TIME}ms cubic-bezier(.2,1.4,.3,1), opacity ${EXPLODE_TIME}ms linear`;
    wrap.appendChild(p);
    particles.push(p);
  }

  function getAnimMs(el, name) {
    const s = getComputedStyle(el);
    const animNames = s.animationName.split(',').map(t => t.trim());
    const animDurations = s.animationDuration.split(',').map(t => t.trim());
    
    const idx = animNames.indexOf(name);
    if (idx === -1) return null;
    let dur = animDurations[idx] || animDurations[0] || '4s';
    dur = dur.endsWith('ms') ? parseFloat(dur) : parseFloat(dur) * 1000;
    return Math.round(dur);
  }

  function explodeOnce() {
    const w = wrap.clientWidth;
    const h = wrap.clientHeight;
    const cx = Math.round(w / 2);
    const cy = Math.round(h / 2);


    particles.forEach(p => {
      p.style.left = cx + 'px';
      p.style.top = cy + 'px';
     
      p.style.transform = `translate(-50%,-50%) translate(0px,0px) scale(0.6)`;
      p.style.opacity = '0.0';
    });

    requestAnimationFrame(() => {
   
      particles.forEach((p, i) => {
        const angle = Math.random() * Math.PI * 2;
        const distance = 48 + Math.random() * 80; 
        const dx = Math.round(Math.cos(angle) * distance);
        const dy = Math.round(Math.sin(angle) * distance);
        const delay = Math.random() * 90; 
        
        setTimeout(() => {
          p.style.transform = `translate(-50%,-50%) translate(${dx}px,${dy}px) scale(1)`;
          p.style.opacity = '1';
        }, delay);
      });

   
      setTimeout(() => {
        particles.forEach((p, i) => {
          const delay2 = Math.random() * 140;
          setTimeout(() => {
            p.style.transform = `translate(-50%,-50%) translate(0px,0px) scale(0.6)`;
            p.style.opacity = '0';
          }, delay2);
        });
      }, EXPLODE_TIME + 120);
    });
  }

  let scheduled = null;
  function scheduleForNextLoop() {
    
    if (scheduled) clearTimeout(scheduled);

    scheduled = setTimeout(explodeOnce, EXPLODE_AT);
  }

  
  scheduleForNextLoop();

  
  shape.addEventListener('animationiteration', () => {
    scheduleForNextLoop();
  });

  
})();
</script>
</body>
</html>
